const ETHIOPIC_ONE: u16 = '፩' as u16;
const ETHIOPIC_TEN: u16 = '፲' as u16;
const ONE: u16 = '1' as u16;

pub fn ethiopic(num: usize) -> String {
    let mut num = num.to_string();
    if num.len() % 2 != 0 {
        num.insert(0, '0')
    }

    let mut num = num.chars().rev().peekable();
    let mut ethiopic_num = String::new();
    let mut pos = 0;
    while let (Some(ascii_one), Some(ascii_ten)) = (num.next(), num.next()) {
        let mut ethio_one: Option<char> = None;
        let mut ethio_ten: Option<char> = None;

        if ascii_one != '0' {
            ethio_one = char::from_u32((ETHIOPIC_ONE + ((ascii_one as u16) - ONE)) as u32);
        }

        if ascii_ten != '0' {
            ethio_ten = char::from_u32((ETHIOPIC_TEN + ((ascii_ten as u16) - ONE)) as u32);
        }

        let sep = if pos > 0 {
            if pos % 2 == 0 {
                "፼"
            } else if ethio_one.is_some() || ethio_ten.is_some() {
                "፻"
            } else {
                ""
            }
        } else {
            ""
        };

        if ethio_one == Some('፩')
            && !sep.is_empty()
            && ethio_ten.is_none()
            && (num.peek().is_none() || sep == "፻")
        {
            ethio_one = None;
        }

        let mut part = String::new();

        ethio_ten.map(|v| {
            part.push(v);
        });

        ethio_one.map(|v| {
            part.push(v);
        });

        part.push_str(sep);
        ethiopic_num.insert_str(0, &part);
        pos += 1;
    }

    ethiopic_num
}

#[cfg(test)]
mod tests {
    use crate::ethiopic;

    #[test]
    fn test() {
        let test_data = [
            (0, ""),
            (1, "፩"),
            (2, "፪"),
            (3, "፫"),
            (4, "፬"),
            (5, "፭"),
            (6, "፮"),
            (7, "፯"),
            (8, "፰"),
            (9, "፱"),
            (10, "፲"),
            (20, "፳"),
            (30, "፴"),
            (40, "፵"),
            (50, "፶"),
            (60, "፷"),
            (70, "፸"),
            (80, "፹"),
            (90, "፺"),
            (100, "፻"),
            (500, "፭፻"),
            (10_000, "፼"),
            (42, "፵፪"),
            (78, "፸፰"),
            (18, "፲፰"),
            (1000, "፲፻"),
            (100_000, "፲፼"),
            (111, "፻፲፩"),
            (666, "፮፻፷፮"),
            (1_000_000, "፻፼"),
            (10_000_000, "፲፻፼"),
            (123, "፻፳፫"),
            (1111, "፲፩፻፲፩"),
            (1234, "፲፪፻፴፬"),
            (6666, "፷፮፻፷፮"),
            (1001, "፲፻፩"),
            (11111, "፼፲፩፻፲፩"),
            (111111, "፲፩፼፲፩፻፲፩"),
        ];

        for (n, e) in test_data {
            assert_eq!(ethiopic(n), e.to_owned());
        }
    }

    #[test]
    fn test_from_website() {
        let test_data = [
            (1, "፩"),
            (10, "፲"),
            (100, "፻"),
            (1000, "፲፻"),
            (10000, "፼"),
            (100000, "፲፼"),
            (1000000, "፻፼"),
            (10000000, "፲፻፼"),
            (100000000, "፼፼"),
            (1000000000, "፲፼፼"),
            (10000000000, "፻፼፼"),
            (100000000000, "፲፻፼፼"),
            (1000000000000, "፼፼፼"),
            (100010000, "፼፩፼"),
            (100100000, "፼፲፼"),
            (100200000, "፼፳፼"),
            (100110000, "፼፲፩፼"),
            (1, "፩"),
            (11, "፲፩"),
            (111, "፻፲፩"),
            (1111, "፲፩፻፲፩"),
            (11111, "፼፲፩፻፲፩"),
            (111111, "፲፩፼፲፩፻፲፩"),
            (1111111, "፻፲፩፼፲፩፻፲፩"),
            (11111111, "፲፩፻፲፩፼፲፩፻፲፩"),
            (111111111, "፼፲፩፻፲፩፼፲፩፻፲፩"),
            (1111111111, "፲፩፼፲፩፻፲፩፼፲፩፻፲፩"),
            (11111111111, "፻፲፩፼፲፩፻፲፩፼፲፩፻፲፩"),
            (111111111111, "፲፩፻፲፩፼፲፩፻፲፩፼፲፩፻፲፩"),
            (1111111111111, "፼፲፩፻፲፩፼፲፩፻፲፩፼፲፩፻፲፩"),
            (1, "፩"),
            (12, "፲፪"),
            (123, "፻፳፫"),
            (1234, "፲፪፻፴፬"),
            (12345, "፼፳፫፻፵፭"),
            (7654321, "፯፻፷፭፼፵፫፻፳፩"),
            (17654321, "፲፯፻፷፭፼፵፫፻፳፩"),
            (51615131, "፶፩፻፷፩፼፶፩፻፴፩"),
            (15161513, "፲፭፻፲፮፼፲፭፻፲፫"),
            (10101011, "፲፻፲፼፲፻፲፩"),
            (101, "፻፩"),
            (1001, "፲፻፩"),
            (1010, "፲፻፲"),
            (1011, "፲፻፲፩"),
            (1100, "፲፩፻"),
            (1101, "፲፩፻፩"),
            (1111, "፲፩፻፲፩"),
            (10001, "፼፩"),
            (10010, "፼፲"),
            (10100, "፼፻"),
            (10101, "፼፻፩"),
            (10110, "፼፻፲"),
            (10111, "፼፻፲፩"),
            (100001, "፲፼፩"),
            (100010, "፲፼፲"),
            (100011, "፲፼፲፩"),
            (100100, "፲፼፻"),
            (101010, "፲፼፲፻፲"),
            (1000001, "፻፼፩"),
            (1000101, "፻፼፻፩"),
            (1000100, "፻፼፻"),
            (1010000, "፻፩፼"),
            (1010001, "፻፩፼፩"),
            (1100001, "፻፲፼፩"),
            (1010101, "፻፩፼፻፩"),
            (101010101, "፼፻፩፼፻፩"),
            (100010000, "፼፩፼"),
            (100010100, "፼፩፼፻"),
            (101010100, "፼፻፩፼፻"),
            (3, "፫"),
            (30, "፴"),
            (33, "፴፫"),
            (303, "፫፻፫"),
            (3003, "፴፻፫"),
            (3030, "፴፻፴"),
            (3033, "፴፻፴፫"),
            (3300, "፴፫፻"),
            (3303, "፴፫፻፫"),
            (3333, "፴፫፻፴፫"),
            (30003, "፫፼፫"),
            (30303, "፫፼፫፻፫"),
            (300003, "፴፼፫"),
            (303030, "፴፼፴፻፴"),
            (3000003, "፫፻፼፫"),
            (3000303, "፫፻፼፫፻፫"),
            (3030003, "፫፻፫፼፫"),
            (3300003, "፫፻፴፼፫"),
            (3030303, "፫፻፫፼፫፻፫"),
            (303030303, "፫፼፫፻፫፼፫፻፫"),
            (333333333, "፫፼፴፫፻፴፫፼፴፫፻፴፫"),
        ];

        for (n, e) in test_data {
            assert_eq!(ethiopic(n), e.to_owned());
        }
    }
}

